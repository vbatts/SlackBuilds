Index: p4ruby/p4ruby-2010.2.295040./p4.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./p4.cpp
+++ p4ruby/p4ruby-2010.2.295040./p4.cpp
@@ -225,7 +225,7 @@ static VALUE p4_set_charset( VALUE self,
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    return p4->SetCharset( STR2CSTR( c ) );
+    return p4->SetCharset( StringValueCStr( c ) );
 }
 
 static VALUE p4_get_p4config( VALUE self )
@@ -248,7 +248,7 @@ static VALUE p4_set_cwd( VALUE self, VAL
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetCwd( STR2CSTR( cwd ) );
+    p4->SetCwd( StringValueCStr( cwd ) );
     return Qtrue;
 }
 
@@ -264,7 +264,7 @@ static VALUE p4_set_client( VALUE self,
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetClient( STR2CSTR( client ) );
+    p4->SetClient( StringValueCStr( client ) );
     return Qtrue;
 }
 
@@ -273,7 +273,7 @@ static VALUE p4_get_env( VALUE self, VAL
     P4ClientApi	*p4;
     const char *val;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    val = p4->GetEnv( STR2CSTR( var ) );
+    val = p4->GetEnv( StringValueCStr( var ) );
     if( !val ) return Qnil;
 
     return rb_str_new2( val );
@@ -291,7 +291,7 @@ static VALUE p4_set_host( VALUE self, VA
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetHost( STR2CSTR( host ) );
+    p4->SetHost( StringValueCStr( host ) );
     return Qtrue;
 }
 
@@ -307,7 +307,7 @@ static VALUE p4_set_language( VALUE self
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetLanguage( STR2CSTR( lang ) );
+    p4->SetLanguage( StringValueCStr( lang ) );
     return Qtrue;
 }
 
@@ -368,7 +368,7 @@ static VALUE p4_set_password( VALUE self
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetPassword( STR2CSTR( passwd ) );
+    p4->SetPassword( StringValueCStr( passwd ) );
     return Qtrue;
 }
 
@@ -387,7 +387,7 @@ static VALUE p4_set_port( VALUE self, VA
     if( p4->Connected() )
 	rb_raise( eP4, "Can't change port once you've connected." );
 
-    p4->SetPort( STR2CSTR( port ) );
+    p4->SetPort( StringValueCStr( port ) );
     return Qtrue;
 }
 
@@ -402,7 +402,7 @@ static VALUE p4_set_prog( VALUE self, VA
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetProg( STR2CSTR( prog ) );
+    p4->SetProg( StringValueCStr( prog ) );
     return Qtrue;
 }
 
@@ -410,7 +410,7 @@ static VALUE p4_set_protocol( VALUE self
 {
     P4ClientApi *p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetProtocol( STR2CSTR( var ), STR2CSTR( val ) );
+    p4->SetProtocol( StringValueCStr( var ), StringValueCStr( val ) );
     return Qtrue;
 }
 
@@ -425,7 +425,7 @@ static VALUE p4_set_ticket_file( VALUE s
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetTicketFile( STR2CSTR( path ) );
+    p4->SetTicketFile( StringValueCStr( path ) );
     return Qtrue;
 }
 
@@ -441,7 +441,7 @@ static VALUE p4_set_user( VALUE self, VA
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetUser( STR2CSTR( user ) );
+    p4->SetUser( StringValueCStr( user ) );
     return Qtrue;
 }
 
@@ -456,7 +456,7 @@ static VALUE p4_set_version( VALUE self,
 {
     P4ClientApi	*p4;
     Data_Get_Struct( self, P4ClientApi, p4 );
-    p4->SetVersion( STR2CSTR( version ) );
+    p4->SetVersion( StringValueCStr( version ) );
     return Qtrue;
 }
 
@@ -535,7 +535,11 @@ static VALUE p4_run( VALUE self, VALUE a
     if ( ! NUM2INT( rb_funcall( flatArgs, idLength, 0 ) ) )
 	rb_raise( eP4, "P4#run requires an argument" );
 
-    char *cmd = STR2CSTR( rb_funcall( flatArgs, rb_intern( "shift" ), 0 ) );
+    // Due the amount of pointers and casts,
+    // I've put this in its own variable, that will get 
+    // reclaimed when out of scope. --vbatts
+    VALUE args_shift = rb_funcall( flatArgs, rb_intern( "shift" ), 0 );
+    char *cmd = StringValueCStr( args_shift );
     argc = NUM2INT( rb_funcall( flatArgs, idLength, 0 ) );
 
     // Allocate storage on the stack so it's automatically reclaimed 
@@ -546,7 +550,11 @@ static VALUE p4_run( VALUE self, VALUE a
     for ( i = 0; i < argc; i++ )
     {
 	VALUE	entry = rb_ary_entry( flatArgs, i );
-	p4args[ i ] = STR2CSTR( rb_funcall( entry, idTo_S, 0 ) );
+	// Due the amount of pointers and casts,
+	// I've put this in its own variable, that will get 
+	// reclaimed when out of scope. --vbatts
+	VALUE	entry_str = rb_funcall( entry, idTo_S, 0 );
+	p4args[ i ] = StringValueCStr( entry_str );
     }
     p4args[ i ] = 0;
 
@@ -614,7 +622,7 @@ static VALUE p4_parse_spec( VALUE self,
     Check_Type( type, T_STRING );
 
     Data_Get_Struct( self, P4ClientApi, p4 );
-    return p4->ParseSpec( STR2CSTR(type), STR2CSTR(form) );
+    return p4->ParseSpec( StringValueCStr(type), StringValueCStr(form) );
 }
 
 static VALUE p4_format_spec( VALUE self, VALUE type, VALUE hash )
@@ -625,7 +633,7 @@ static VALUE p4_format_spec( VALUE self,
     Check_Type( hash, T_HASH );
 
     Data_Get_Struct( self, P4ClientApi, p4 );
-    return p4->FormatSpec( STR2CSTR(type), hash );
+    return p4->FormatSpec( StringValueCStr(type), hash );
 }
 
 static VALUE p4_track_output( VALUE self )
Index: p4ruby/p4ruby-2010.2.295040./clientuserruby.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./clientuserruby.cpp
+++ p4ruby/p4ruby-2010.2.295040./clientuserruby.cpp
@@ -348,7 +348,7 @@ ClientUserRuby::InputData( StrBuf *strbu
     // Convert whatever's left into a string
     ID	to_s 	= rb_intern( "to_s" );
     VALUE	str 	= rb_funcall( inval, to_s, 0 );
-    strbuf->Set( STR2CSTR( str ) );
+    strbuf->Set( StringValueCStr( str ) );
 }
 
 /*
@@ -413,7 +413,7 @@ ClientUserRuby::Resolve( ClientMerge *m,
 	if( excepted ) return CMS_QUIT;
 
    
-	reply = STR2CSTR( r ); 
+	reply = StringValueCStr( r ); 
 
 	if( reply == "ay" ) 		return CMS_YOURS;
 	else if( reply == "at" )	return CMS_THEIRS;
Index: p4ruby/p4ruby-2010.2.295040./p4mapmaker.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./p4mapmaker.cpp
+++ p4ruby/p4ruby-2010.2.295040./p4mapmaker.cpp
@@ -97,7 +97,7 @@ P4MapMaker::Insert( VALUE m )
     StrRef	l;
     MapType	t = MapInclude;
 
-    in = STR2CSTR( m );
+    in = StringValueCStr( m );
     SplitMapping( in, lbuf, r );
 
     l = lbuf.Text();
@@ -130,7 +130,7 @@ P4MapMaker::Insert( VALUE l, VALUE r )
     const char *p;
     MapType	t = MapInclude;
 
-    p = STR2CSTR( l );
+    p = StringValueCStr( l );
     for( ; ; )
     {
 	for( index = 0; *p; p++ )
@@ -177,7 +177,7 @@ P4MapMaker::Insert( VALUE l, VALUE r )
 	    break;
 
 	dest = &right;
-	p = STR2CSTR( r );
+	p = StringValueCStr( r );
 	quoted = 0;
     }
     left.Terminate();
@@ -229,7 +229,7 @@ P4MapMaker::Translate( VALUE p, int fwd
     if( !fwd )
 	dir = MapRightLeft;
 
-    from = STR2CSTR( p );
+    from = StringValueCStr( p );
     if( map->Translate( from, to, dir ) )
 	return rb_str_new( to.Text(), to.Length() );
     return Qnil;
Index: p4ruby/p4ruby-2010.2.295040./p4result.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./p4result.cpp
+++ p4ruby/p4ruby-2010.2.295040./p4result.cpp
@@ -237,7 +237,7 @@ P4Result::Fmt( const char *label, VALUE
 
     // Join the array elements together, and append the result to the buffer
     s1 		= rb_funcall( ary, idJoin, 1, rsep );
-    buf << STR2CSTR( s1 );
+    buf << StringValueCStr( s1 );
 
     return;
 }
Index: p4ruby/p4ruby-2010.2.295040./p4specdata.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./p4specdata.cpp
+++ p4ruby/p4ruby-2010.2.295040./p4specdata.cpp
@@ -60,7 +60,7 @@ SpecDataRuby::GetLine( SpecElem *sd, int
 
 	if( !sd->IsList() )
 	{
-	    last = STR2CSTR( val );
+	    last = StringValueCStr( val );
 	    return &last;
 	}
 
@@ -75,7 +75,7 @@ SpecDataRuby::GetLine( SpecElem *sd, int
 	val = rb_ary_entry( val, x );
 	if( val == Qnil ) return 0;
 
-	last = STR2CSTR( val );
+	last = StringValueCStr( val );
 	return &last;
 }
 
Index: p4ruby/p4ruby-2010.2.295040./specmgr.cpp
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./specmgr.cpp
+++ p4ruby/p4ruby-2010.2.295040./specmgr.cpp
@@ -476,7 +476,7 @@ SpecMgr::InsertItem( VALUE hash, const S
 	    key = rb_funcall( key, idPlus, 1, rb_str_new2( "s" ) );
 	
 	if( P4RDB_DATA )
-	    fprintf( stderr, "... %s -> %s\n", STR2CSTR( key ), val->Text() );
+	    fprintf( stderr, "... %s -> %s\n", StringValueCStr( key ), val->Text() );
 
 	rb_hash_aset( hash, key, rb_str_new2( val->Text() ) );
 	return;
Index: p4ruby/p4ruby-2010.2.295040./p4conf.rb
===================================================================
--- p4ruby.orig/p4ruby-2010.2.295040./p4conf.rb
+++ p4ruby/p4ruby-2010.2.295040./p4conf.rb
@@ -577,7 +577,7 @@ end
 # Check that the version of the API is one we can cope with, or that the
 # user wants to punt.
 #
-exit( 1 ) unless check_ruby_version
+#exit( 1 ) unless check_ruby_version
 exit( 1 ) unless check_api_version( $apiver )
 
 set_apidir( $apidir )
